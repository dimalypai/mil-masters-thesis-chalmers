type Maybe A
  = Nothing
  | Just A;

type String
  = Empty_Str
  | Cons_Str Char String;

printString : String -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(s_ : String) ->
    case s_ of
      | Empty_Str => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                       unit
      | Cons_Str (c_ : Char) (cs_ : String) => let (unit_0 : Unit) <-
                                                 lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] print_char c_
                                               in printString cs_
    end;

readString : (Error Unit ::: (NonTerm ::: (State ::: IO))) String =
  readString_ Empty_Str;

readString_ : String -> (Error Unit ::: (NonTerm ::: (State ::: IO))) String =
  \(acc_ : String) ->
    let (c_ : Char) <-
      lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
    in case c_ of
         | ' ' => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                    reverseString_ acc_ Empty_Str
         | _ => readString_ (Cons_Str c_ acc_)
       end;

reverseString_ : String -> String -> String =
  \(s_ : String) ->
    \(acc_ : String) ->
      case s_ of
        | Empty_Str => acc_
        | Cons_Str (c_ : Char) (cs_ : String) => reverseString_ cs_ (Cons_Str c_ acc_)
      end;

printBool : Bool -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(b_ : Bool) ->
    case b_ of
      | True => printString (Cons_Str 't' (Cons_Str 'r' (Cons_Str 'u' (Cons_Str 'e' Empty_Str))))
      | False => printString (Cons_Str 'f' (Cons_Str 'a' (Cons_Str 'l' (Cons_Str 's' (Cons_Str 'e' Empty_Str)))))
    end;

readBool : (Error Unit ::: (NonTerm ::: (State ::: IO))) Bool =
  let (c_1 : Char) <-
    lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
  in case c_1 of
       | 't' => let (c_2 : Char) <-
                  lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                in case c_2 of
                     | 'r' => let (c_3 : Char) <-
                                lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                              in case c_3 of
                                   | 'u' => let (c_4 : Char) <-
                                              lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                            in case c_4 of
                                                 | 'e' => let (c_5 : Char) <-
                                                            lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                                          in case c_5 of
                                                               | ' ' => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                          True
                                                               | _ => let (errRes_ : Bool) <-
                                                                        throw_error [Unit] [Bool] unit
                                                                      in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                           errRes_
                                                             end
                                                 | _ => let (errRes_ : Bool) <-
                                                          throw_error [Unit] [Bool] unit
                                                        in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                             errRes_
                                               end
                                   | _ => let (errRes_ : Bool) <-
                                            throw_error [Unit] [Bool] unit
                                          in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                               errRes_
                                 end
                     | _ => let (errRes_ : Bool) <-
                              throw_error [Unit] [Bool] unit
                            in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                 errRes_
                   end
       | 'f' => let (c_2 : Char) <-
                  lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                in case c_2 of
                     | 'a' => let (c_3 : Char) <-
                                lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                              in case c_3 of
                                   | 'l' => let (c_4 : Char) <-
                                              lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                            in case c_4 of
                                                 | 's' => let (c_5 : Char) <-
                                                            lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                                          in case c_5 of
                                                               | 'e' => let (c_6 : Char) <-
                                                                          lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                                                        in case c_6 of
                                                                             | ' ' => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                                        False
                                                                             | _ => let (errRes_ : Bool) <-
                                                                                      throw_error [Unit] [Bool] unit
                                                                                    in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                                         errRes_
                                                                           end
                                                               | _ => let (errRes_ : Bool) <-
                                                                        throw_error [Unit] [Bool] unit
                                                                      in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                           errRes_
                                                             end
                                                 | _ => let (errRes_ : Bool) <-
                                                          throw_error [Unit] [Bool] unit
                                                        in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                             errRes_
                                               end
                                   | _ => let (errRes_ : Bool) <-
                                            throw_error [Unit] [Bool] unit
                                          in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                               errRes_
                                 end
                     | _ => let (errRes_ : Bool) <-
                              throw_error [Unit] [Bool] unit
                            in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                 errRes_
                   end
       | _ => let (errRes_ : Bool) <-
                throw_error [Unit] [Bool] unit
              in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                   errRes_
     end;

printInt : Int -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(i_ : Int) ->
    return [Error Unit ::: (NonTerm ::: (State ::: IO))]
      unit;

readInt : (Error Unit ::: (NonTerm ::: (State ::: IO))) Int =
  return [Error Unit ::: (NonTerm ::: (State ::: IO))]
    1;

printFloat : Float -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(f_ : Float) ->
    return [Error Unit ::: (NonTerm ::: (State ::: IO))]
      unit;

readFloat : (Error Unit ::: (NonTerm ::: (State ::: IO))) Float =
  return [Error Unit ::: (NonTerm ::: (State ::: IO))]
    1.0;

new_Empty_Data : (Error Unit ::: NonTerm) {} =
  return [Error Unit ::: NonTerm] {};

new_Empty : (Error Unit ::: NonTerm) {{}, {}} =
  let (self_data : {}) <- new_Empty_Data
  in class_Empty self_data;

class_Empty : {} -> (Error Unit ::: NonTerm) {{}, {}} =
  \(self_data : {}) ->
    let rec (self : {{}, {}}) <- {self_data, {}}
    in return [Error Unit ::: NonTerm] self;

new_Super_Data : (Error Unit ::: NonTerm) {Int, Bool} =
  let (self_superField : Int) <- return [Error Unit ::: NonTerm] 1
  in let (self_superField2 : Bool) <- return [Error Unit ::: NonTerm] True
     in return [Error Unit ::: NonTerm] {self_superField, self_superField2};

new_Super : (Error Unit ::: NonTerm) {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} =
  let (self_data : {Int, Bool}) <- new_Super_Data
  in class_Super self_data;

class_Super : {Int, Bool} -> (Error Unit ::: NonTerm) {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} =
  \(self_data : {Int, Bool}) ->
    let rec (self : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) <-
      { self_data
      , { \(lazy_ : Unit) ->
            \(u : Unit) ->
              let (var_0 : Int) <- return [Error Unit ::: NonTerm] 1
              in let (var_1 : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) <-
                return [Error Unit ::: NonTerm] self
              in case var_1 of
                   | {var_2 : {Int, Bool}, var_3 : {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} =>
                       case var_2 of
                         | {superField : Int, superField2 : Bool} =>
                             case var_3 of
                               | {method : Unit -> Unit -> (Error Unit ::: NonTerm) Int} =>
                                   return [Error Unit ::: NonTerm] superField
                             end
                       end
                 end
        }
      }
    in return [Error Unit ::: NonTerm] self;

new_Child_Data : (Error Unit ::: NonTerm) {Int, Bool, Float} =
  let (self_superField : Int) <- return [Error Unit ::: NonTerm] 1
  in let (self_superField2 : Bool) <- return [Error Unit ::: NonTerm] True
  in let (self_childField : Float) <- return [Error Unit ::: NonTerm] 1.0e-2
  in return [Error Unit ::: NonTerm] {self_superField, self_superField2, self_childField};

new_Child : (Error Unit ::: NonTerm) {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}} =
  let (self_data : {Int, Bool, Float}) <- new_Child_Data
  in class_Child self_data;

class_Child : {Int, Bool, Float} -> (Error Unit ::: NonTerm) {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}} =
  \(self_data : {Int, Bool, Float}) ->
    let (super : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) <- new_Super
    in let rec (self : {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}}) <-
         case super of
           | {super_data : {Int, Bool}, super_methods : {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} =>
               case super_methods of
                 | {super_method : Unit -> Unit -> (Error Unit ::: NonTerm) Int} =>
                     { self_data
                     , { \(lazy_ : Unit) ->
                           \(u : Unit) ->
                             let (var_7 : Float) <-
                               let (var_4 : {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}}) <-
                                 return [Error Unit ::: NonTerm] self
                               in case var_4 of
                                    | {var_5 : {Int, Bool, Float}, var_6 : {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}} =>
                                        case var_5 of
                                          | {superField : Int, superField2 : Bool, childField : Float} =>
                                              case var_6 of
                                                | {method : Unit -> Unit -> (Error Unit ::: NonTerm) Int, childMethod : Unit -> (Error Unit ::: NonTerm) Float} =>
                                                    return [Error Unit ::: NonTerm] childField
                                              end
                                        end
                                  end
                               in return [Error Unit ::: NonTerm] 2
                       , \(lazy_ : Unit) ->
                           let (var_11 : Int) <-
                             let (var_8 : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) <-
                               return [Error Unit ::: NonTerm] super
                             in case var_8 of
                                  | {var_9 : {Int, Bool}, var_10 : {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} =>
                                      case var_9 of
                                        | {superField : Int, superField2 : Bool} =>
                                            case var_10 of
                                              | {method : Unit -> Unit -> (Error Unit ::: NonTerm) Int} => return [Error Unit ::: NonTerm] superField
                                            end
                                      end
                                end
                             in let (var_15 : Int) <-
                                  let (var_12 : {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}}) <-
                                    return [Error Unit ::: NonTerm] self
                                  in case var_12 of
                                       | {var_13 : {Int, Bool, Float}, var_14 : {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}} =>
                                           case var_13 of
                                             | {superField : Int, superField2 : Bool, childField : Float} =>
                                                 case var_14 of
                                                   | {method : Unit -> Unit -> (Error Unit ::: NonTerm) Int, childMethod : Unit -> (Error Unit ::: NonTerm) Float} =>
                                                       return [Error Unit ::: NonTerm] superField
                                                 end
                                           end
                                     end
                                  in let (var_16 : {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}}) <-
                                       return [Error Unit ::: NonTerm] self
                                     in case var_16 of
                                          | {var_17 : {Int, Bool, Float}, var_18 : {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}} =>
                                              case var_17 of
                                                | {superField : Int, superField2 : Bool, childField : Float} =>
                                                    case var_18 of
                                                      | {method : Unit -> Unit -> (Error Unit ::: NonTerm) Int, childMethod : Unit -> (Error Unit ::: NonTerm) Float} =>
                                                          return [Error Unit ::: NonTerm] childField
                                                    end
                                              end
                                        end
                       }
                     }
               end
         end
       in return [Error Unit ::: NonTerm] self;

main : (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  let (objSuper : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) <- new_Super
  in let (objChild : {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}}) <- new_Child
  in let (var_21 : Int) <-
       let (var_19 : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} -> (Error Unit ::: NonTerm) Int) <-
         return [Error Unit ::: (NonTerm ::: (State ::: IO))] fun
       in let (var_20 : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) <-
            return [Error Unit ::: (NonTerm ::: (State ::: IO))] objSuper
          in var_19 var_20
  in let (var_24 : Int) <-
       let (var_22 : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} -> (Error Unit ::: NonTerm) Int) <-
          return [Error Unit ::: (NonTerm ::: (State ::: IO))] fun
       in let (var_23 : {{Int, Bool, Float}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int, Unit -> (Error Unit ::: NonTerm) Float}}) <-
            return [Error Unit ::: (NonTerm ::: (State ::: IO))] objChild
       in var_22 var_23
     in return [Error Unit ::: (NonTerm ::: (State ::: IO))] unit;

fun : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}} -> (Error Unit ::: NonTerm) Int =
  \(obj : {{Int, Bool}, {Unit -> Unit -> (Error Unit ::: NonTerm) Int}}) ->
    return [Error Unit ::: NonTerm] 1;

