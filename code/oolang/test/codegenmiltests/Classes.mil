type Bool
  = True
  | False;

type Maybe A
  = Nothing
  | Just A;

alias Impure_M = Error Unit ::: State ::: Lift ::: IO ::: Id;

type Super_Data = Super_Data {Int};

type Super = Super {Unit -> Unit -> Id Int, Unit -> Id Bool, Super_Data};

type Child_Data = Child_Data {Int, Float};

type Child = Child {Unit -> Unit -> Id Int, Unit -> Id Bool, Unit -> Id Float, Child_Data};

new_Super_Data : Super_Data =
  Super_Data {1};

class_Super : Super_Data -> Id Super =
  \(self_data : Super_Data) ->
    case self_data of
      | Super_Data self_fields =>
          case self_fields of
            | {self_superField} =>
                let rec (self : Super) =
                  case self of
                    | Super self_methods =>
                        case self_methods of
                          | {self_method, self_superMethod, var_0} =>
                              Super {\(var_0 : Unit) ->
                                       \(u : Unit) ->
                                         return [Id] self_superField, \(var_1 : Unit) ->
                                                                        return [Id] True, self_data} in return [Id] self
                        end
                  end
          end
    end;

new_Super : Id Super =
  class_Super new_Super_Data;

class_Child : Child_Data -> Id Child =
  \(self_data : Child_Data) ->
    let (super : Super) <- class_Super self_data in
      case super of
        | Super super_methods =>
            case super_methods of
              | {super_method, super_superMethod} =>
                  case self_data of
                    | Child_Data self_fields =>
                        case self_fields of
                          | {self_superField, self_childField} =>
                              let rec (self : Child) =
                                case self of
                                  | Child self_methods =>
                                      case self_methods of
                                        | {self_method, self_superMethod, self_childMethod} =>
                                            Child {\(var_0 : Unit) ->
                                                     \(u : Unit) ->
                                                       super_method u, super_superMethod, \(var_1 : Unit) -> self_superField} in return [Id] self;
                                      end
                                end
                        end
                  end
            end
      end;

new_Child_Data : Child_Data =
  case new_Super_Data of
    | Super_Data {super_superField} => Child_Data {super_superField, 1.0e-2}
  end;

new_Child : Id Child =
  class_Child new_Child_Data;

main : Impure_M Unit =
  let (objSuper : Super) <- lift [Id -> Impure_M] new_Super in
    let (objChild : Child) <- lift [Id -> Impure_M] new_Child in
      let (_ : Int) <- lift [Id -> Impure_M] fun objSuper in
        case objChild of
          | Child objChild_methods =>
              let (_ : Int) <- lift [Id -> Impure_M] fun (Super objChild_methods) in
                return [Impure_M] unit;
              end
        end;

fun : Super -> Id Int =
  \(obj : Super) ->
    case obj of
      | Super obj_methods =>
          case obj_methods of
            | {obj_method, obj_superMethod} =>
                obj_method unit unit
          end
    end;

