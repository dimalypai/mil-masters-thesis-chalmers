type Maybe A
  = Nothing
  | Just A;

type String
  = Empty_Str
  | Cons_Str Char String;

type Empty_Data = Empty_Data {};

type Empty = Empty {Empty_Data};

type Super_Data = Super_Data {Int, Bool};

type Super = Super {Super_Data};

type Child_Data = Child_Data {Int, Bool};

type Child = Child {Child_Data};

printString : String -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(s_ : String) ->
    case s_ of
      | Empty_Str => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                       unit
      | Cons_Str (c_ : Char) (cs_ : String) => let (unit_0 : Unit) <-
                                                 lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] print_char c_
                                               in printString cs_
    end;

readString : (Error Unit ::: (NonTerm ::: (State ::: IO))) String =
  readString_ Empty_Str;

readString_ : String -> (Error Unit ::: (NonTerm ::: (State ::: IO))) String =
  \(acc_ : String) ->
    let (c_ : Char) <-
      lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
    in case c_ of
         | ' ' => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                    reverseString_ acc_ Empty_Str
         | _ => readString_ (Cons_Str c_ acc_)
       end;

reverseString_ : String -> String -> String =
  \(s_ : String) ->
    \(acc_ : String) ->
      case s_ of
        | Empty_Str => acc_
        | Cons_Str (c_ : Char) (cs_ : String) => reverseString_ cs_ (Cons_Str c_ acc_)
      end;

printBool : Bool -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(b_ : Bool) ->
    case b_ of
      | True => printString (Cons_Str 't' (Cons_Str 'r' (Cons_Str 'u' (Cons_Str 'e' Empty_Str))))
      | False => printString (Cons_Str 'f' (Cons_Str 'a' (Cons_Str 'l' (Cons_Str 's' (Cons_Str 'e' Empty_Str)))))
    end;

readBool : (Error Unit ::: (NonTerm ::: (State ::: IO))) Bool =
  let (c_1 : Char) <-
    lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
  in case c_1 of
       | 't' => let (c_2 : Char) <-
                  lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                in case c_2 of
                     | 'r' => let (c_3 : Char) <-
                                lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                              in case c_3 of
                                   | 'u' => let (c_4 : Char) <-
                                              lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                            in case c_4 of
                                                 | 'e' => let (c_5 : Char) <-
                                                            lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                                          in case c_5 of
                                                               | ' ' => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                          True
                                                               | _ => let (errRes_ : Bool) <-
                                                                        throw_error [Unit] [Bool] unit
                                                                      in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                           errRes_
                                                             end
                                                 | _ => let (errRes_ : Bool) <-
                                                          throw_error [Unit] [Bool] unit
                                                        in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                             errRes_
                                               end
                                   | _ => let (errRes_ : Bool) <-
                                            throw_error [Unit] [Bool] unit
                                          in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                               errRes_
                                 end
                     | _ => let (errRes_ : Bool) <-
                              throw_error [Unit] [Bool] unit
                            in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                 errRes_
                   end
       | 'f' => let (c_2 : Char) <-
                  lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                in case c_2 of
                     | 'a' => let (c_3 : Char) <-
                                lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                              in case c_3 of
                                   | 'l' => let (c_4 : Char) <-
                                              lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                            in case c_4 of
                                                 | 's' => let (c_5 : Char) <-
                                                            lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                                          in case c_5 of
                                                               | 'e' => let (c_6 : Char) <-
                                                                          lift [IO => Error Unit ::: (NonTerm ::: (State ::: IO))] read_char
                                                                        in case c_6 of
                                                                             | ' ' => return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                                        False
                                                                             | _ => let (errRes_ : Bool) <-
                                                                                      throw_error [Unit] [Bool] unit
                                                                                    in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                                         errRes_
                                                                           end
                                                               | _ => let (errRes_ : Bool) <-
                                                                        throw_error [Unit] [Bool] unit
                                                                      in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                                           errRes_
                                                             end
                                                 | _ => let (errRes_ : Bool) <-
                                                          throw_error [Unit] [Bool] unit
                                                        in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                                             errRes_
                                               end
                                   | _ => let (errRes_ : Bool) <-
                                            throw_error [Unit] [Bool] unit
                                          in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                               errRes_
                                 end
                     | _ => let (errRes_ : Bool) <-
                              throw_error [Unit] [Bool] unit
                            in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                                 errRes_
                   end
       | _ => let (errRes_ : Bool) <-
                throw_error [Unit] [Bool] unit
              in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
                   errRes_
     end;

printInt : Int -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(i_ : Int) ->
    return [Error Unit ::: (NonTerm ::: (State ::: IO))]
      unit;

readInt : (Error Unit ::: (NonTerm ::: (State ::: IO))) Int =
  return [Error Unit ::: (NonTerm ::: (State ::: IO))]
    1;

printFloat : Float -> (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  \(f_ : Float) ->
    return [Error Unit ::: (NonTerm ::: (State ::: IO))]
      unit;

readFloat : (Error Unit ::: (NonTerm ::: (State ::: IO))) Float =
  return [Error Unit ::: (NonTerm ::: (State ::: IO))]
    1.0;

new_Empty_Data : (Error Unit ::: NonTerm) Empty_Data =
  return [Error Unit ::: NonTerm] Empty_Data {};

new_Empty : (Error Unit ::: NonTerm) Empty =
  let (self_data : Empty_Data) <- new_Empty_Data
  in class_Empty self_data;

class_Empty : Empty_Data -> (Error Unit ::: NonTerm) Empty =
  \(self_data : Empty_Data) ->
    return [Error Unit ::: NonTerm] Empty {self_data};

new_Super_Data : (Error Unit ::: NonTerm) Super_Data =
  let (self_superField : Int) <- return [Error Unit ::: NonTerm] 1
  in let (self_superField2 : Bool) <- return [Error Unit ::: NonTerm] True
     in return [Error Unit ::: NonTerm] Super_Data {self_superField, self_superField2};

new_Super : (Error Unit ::: NonTerm) Super =
  let (self_data : Super_Data) <- new_Super_Data
  in class_Super self_data;

class_Super : Super_Data -> (Error Unit ::: NonTerm) Super =
  \(self_data : Super_Data) ->
    return [Error Unit ::: NonTerm] Super {self_data};

new_Child_Data : (Error Unit ::: NonTerm) Child_Data =
  let (self_superField : Int) <- return [Error Unit ::: NonTerm] 1
  in let (self_superField2 : Bool) <- return [Error Unit ::: NonTerm] True
        in return [Error Unit ::: NonTerm] Child_Data {self_superField, self_superField2};

new_Child : (Error Unit ::: NonTerm) Child =
  let (self_data : Child_Data) <- new_Child_Data
  in class_Child self_data;

class_Child : Child_Data -> (Error Unit ::: NonTerm) Child =
  \(self_data : Child_Data) ->
    return [Error Unit ::: NonTerm] Child {self_data};

main : (Error Unit ::: (NonTerm ::: (State ::: IO))) Unit =
  let (objSuper : Super) <- new_Super
  in let (objChild : Child) <- new_Child
     in return [Error Unit ::: (NonTerm ::: (State ::: IO))]
          unit;

