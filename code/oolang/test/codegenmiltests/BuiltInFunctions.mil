type Maybe A
  = Nothing
  | Just A;

type String
  = Empty
  | StrCons Char String;

alias Pure_M = Error Unit ::: NonTerm;

alias Impure_M = Error Unit ::: NonTerm ::: State ::: IO;

printString : String -> IO Unit =
  \(str : String) -> case str of
                       | Empty => return [IO] unit;
                       | StrCons (c : Char) (cs : String) => let (_ : Unit) <- print_char c in
                                                               printString cs
                     end;

printBool : Bool -> IO Unit =
  \(b : Bool) -> case b of
                   | True => printString (StrCons 't' (StrCons 'r' (StrCons 'u' (StrCons 'e' Empty))))
                   | False => printString (StrCons 'f' (StrCons 'a' (StrCons 'l' (StrCons 's' (StrCons 'e' Empty)))))
                 end;

readBool : Impure_M Bool =
  let (c_1 : Char) <- read_char in
    case c_1 of
      | 't' => let (c_2 : Char) <- read_char in
                 case c_2 of
                   | 'r' => return [Impure_M] True
                   | _ => throw_error [Unit] [Bool] unit
                 end
      | 'f' => let (c_2 : Char) <- read_char in
                 case c_2 of
                   | 'a' => return [Impure_M] False
                   | _ => throw_error [Unit] [Bool] unit
                 end
      | _ => throw_error [Unit] [Bool] unit
    end;

printInt : Int -> IO Unit =

readInt : Impure_M Int =

printFloat : Float -> IO Unit =

readFloat : Impure_M Float =

main : Impure_M Unit =
  let (_ : Unit) <- let (var_0 : String -> IO Unit) <- return [Impure_M] print_string in
                      let (var_1 : String) <- return [Impure_M] "Hello from main" in
                        lift [IO -> Impure_M] var_0 var_1 in
    let (b : Bool) <- readBool in
      let (_ : Unit) <- let (var_2 : Bool -> IO Unit) <- return [Impure_M] printBool in
                          let (var_3 : Bool) <- return [Impure_M] b in
                            lift [IO -> Impure_M] var_2 var_3 in
        let (i : Int) <- read_int in
          let (_ : Unit) <- let (var_4 : Int -> IO Unit) <- return [Impure_M] print_int in
                              let (var_5 : Int) <- return [Impure_M] i in
                                lift [IO -> Impure_M] var_4 var_5 in
            let (f : Float) <- read_float in
              let (var_6 : Float -> IO Unit) <- return [Impure_M] print_float in
                let (var_7 : Float) <- return [Impure_M] f in
                  lift [IO -> Impure_M] var_6 var_7;

