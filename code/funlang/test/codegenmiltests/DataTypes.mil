type String
  = Empty_Str
  | Cons_Str Char String;

type S = MkS;

type T = MkT (Int -> (Error Unit ::: NonTerm) Unit) | MkTT;

type Pair A B = MkPair A B;

type IoWrapper A = MkIO ((Error Unit ::: (NonTerm ::: IO)) A);

type StateWrapper St A = MkState ((Error Unit ::: (NonTerm ::: State)) A);

type BuiltInMonadFunWrapper
  = IoFun (Unit -> (Error Unit ::: (NonTerm ::: IO)) Unit)
  | StateFun (Int -> (Error Unit ::: (NonTerm ::: State)) Unit);

type BuiltInMonadForAllWrapper
  = IoForAll (forall A . (Error Unit ::: (NonTerm ::: IO)) A)
  | StateForAll (forall A . (Error Unit ::: (NonTerm ::: State)) A);

con_True : (Error Unit ::: NonTerm) Bool =
  return [Error Unit ::: NonTerm] True;

con_False : (Error Unit ::: NonTerm) Bool =
  return [Error Unit ::: NonTerm] False;

con_MkS : (Error Unit ::: NonTerm) S =
  return [Error Unit ::: NonTerm] MkS;

con_MkT : (Error Unit ::: NonTerm) ((Int -> (Error Unit ::: NonTerm) Unit) -> (Error Unit ::: NonTerm) T) =
  return [Error Unit ::: NonTerm] \(var_0 : Int -> (Error Unit ::: NonTerm) Unit) -> return [Error Unit ::: NonTerm] MkT var_0;

con_MkTT : (Error Unit ::: NonTerm) T =
  return [Error Unit ::: NonTerm] MkTT;

con_MkPair : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) (forall B . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) (Pair A B))))) =
  return [Error Unit ::: NonTerm] /\A .
    return [Error Unit ::: NonTerm] /\B .
      return [Error Unit ::: NonTerm] \(var_1 : A) ->
        return [Error Unit ::: NonTerm] \(var_2 : B) ->
          return [Error Unit ::: NonTerm] MkPair [A] [B] var_1 var_2;

con_MkIO : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) ((Error Unit ::: (NonTerm ::: IO)) A -> (Error Unit ::: NonTerm) (IoWrapper A))) =
  return [Error Unit ::: NonTerm] /\A .
    return [Error Unit ::: NonTerm] \(var_3 : (Error Unit ::: (NonTerm ::: IO)) A) ->
      return [Error Unit ::: NonTerm] MkIO [A] var_3;

con_MkState : (Error Unit ::: NonTerm) (forall St . (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) ((Error Unit ::: (NonTerm ::: State)) A -> (Error Unit ::: NonTerm) (StateWrapper St A)))) =
  return [Error Unit ::: NonTerm] /\St .
    return [Error Unit ::: NonTerm] /\A .
      return [Error Unit ::: NonTerm] \(var_4 : (Error Unit ::: (NonTerm ::: State)) A) ->
        return [Error Unit ::: NonTerm] MkState [St] [A] var_4;

con_IoFun : (Error Unit ::: NonTerm) ((Unit -> (Error Unit ::: (NonTerm ::: IO)) Unit) -> (Error Unit ::: NonTerm) BuiltInMonadFunWrapper) =
  return [Error Unit ::: NonTerm] \(var_5 : Unit -> (Error Unit ::: (NonTerm ::: IO)) Unit) ->
    return [Error Unit ::: NonTerm] IoFun var_5;

con_StateFun : (Error Unit ::: NonTerm) ((Int -> (Error Unit ::: (NonTerm ::: State)) Unit) -> (Error Unit ::: NonTerm) BuiltInMonadFunWrapper) =
  return [Error Unit ::: NonTerm] \(var_6 : Int -> (Error Unit ::: (NonTerm ::: State)) Unit) ->
    return [Error Unit ::: NonTerm] StateFun var_6;

con_IoForAll : (Error Unit ::: NonTerm) ((forall A . (Error Unit ::: (NonTerm ::: IO)) A) -> (Error Unit ::: NonTerm) BuiltInMonadForAllWrapper) =
  return [Error Unit ::: NonTerm] \(var_7 : forall A . (Error Unit ::: (NonTerm ::: IO)) A) ->
    return [Error Unit ::: NonTerm] IoForAll var_7;

con_StateForAll : (Error Unit ::: NonTerm) ((forall A . (Error Unit ::: (NonTerm ::: State)) A) -> (Error Unit ::: NonTerm) BuiltInMonadForAllWrapper) =
  return [Error Unit ::: NonTerm] \(var_8 : forall A . (Error Unit ::: (NonTerm ::: State)) A) ->
    return [Error Unit ::: NonTerm] StateForAll var_8;

main : (Error Unit ::: (NonTerm ::: IO)) Unit =
  return [Error Unit ::: (NonTerm ::: IO)] unit;

mkS : (Error Unit ::: NonTerm) S =
  con_MkS;

mkT : (Error Unit ::: NonTerm) ((Int -> (Error Unit ::: NonTerm) Unit) -> (Error Unit ::: NonTerm) T) =
  con_MkT;

mkPair : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) (forall B . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) (Pair A B))))) =
  con_MkPair;

mkIo : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) ((Error Unit ::: (NonTerm ::: IO)) A -> (Error Unit ::: NonTerm) (IoWrapper A))) =
  con_MkIO;

mkState : (Error Unit ::: NonTerm) (forall St . (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) ((Error Unit ::: (NonTerm ::: State)) A -> (Error Unit ::: NonTerm) (StateWrapper St A)))) =
  con_MkState;

