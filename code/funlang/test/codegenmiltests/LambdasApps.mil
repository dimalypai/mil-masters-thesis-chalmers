type String
  = Empty_Str
  | Cons_Str Char String;

con_True : (Error Unit ::: NonTerm) Bool =
  return [Error Unit ::: NonTerm] True;

con_False : (Error Unit ::: NonTerm) Bool =
  return [Error Unit ::: NonTerm] False;

printString : (Error Unit ::: NonTerm) (String -> (Error Unit ::: (NonTerm ::: IO)) Unit) =
  return [Error Unit ::: NonTerm] \(s : String) ->
    return [Error Unit ::: (NonTerm ::: IO)] unit;

readString : (Error Unit ::: (NonTerm ::: IO)) String =
  return [Error Unit ::: (NonTerm ::: IO)] Empty_Str;

printInt : (Error Unit ::: NonTerm) (Int -> (Error Unit ::: (NonTerm ::: IO)) Unit) =
  return [Error Unit ::: NonTerm] \(i : Int) ->
    return [Error Unit ::: (NonTerm ::: IO)] unit;

readInt : (Error Unit ::: (NonTerm ::: IO)) Int =
  return [Error Unit ::: (NonTerm ::: IO)] 1;

printFloat : (Error Unit ::: NonTerm) (Float -> (Error Unit ::: (NonTerm ::: IO)) Unit) =
  return [Error Unit ::: NonTerm] \(f : Float) ->
    return [Error Unit ::: (NonTerm ::: IO)] unit;

readFloat : (Error Unit ::: (NonTerm ::: IO)) Float =
  return [Error Unit ::: (NonTerm ::: IO)] 1.0;

main : (Error Unit ::: (NonTerm ::: IO)) Unit =
  return [Error Unit ::: (NonTerm ::: IO)] unit;

unitId : (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Unit) =
  return [Error Unit ::: NonTerm] \(a : Unit) -> return [Error Unit ::: NonTerm] a;

multParamsFun : (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Float)) =
  return [Error Unit ::: NonTerm] \(x : Int) ->
    return [Error Unit ::: NonTerm] \(y : Unit) ->
      return [Error Unit ::: NonTerm] 1.0;

multParamsFunNested : (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Float)) =
  return [Error Unit ::: NonTerm] \(x : Int) ->
    return [Error Unit ::: NonTerm] \(y : Unit) ->
      return [Error Unit ::: NonTerm] 2.0;

simpleApp : (Error Unit ::: NonTerm) Unit =
  let (var_0 : Unit -> (Error Unit ::: NonTerm) Unit) <- unitId in
    let (var_1 : Unit) <- return [Error Unit ::: NonTerm] unit in
      var_0 var_1;

partialApp : (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Float) =
  let (var_2 : Int -> (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Float)) <- multParamsFun in
    let (var_3 : Int) <- return [Error Unit ::: NonTerm] 1 in
      var_2 var_3;

fullApp : (Error Unit ::: NonTerm) Float =
  let (var_6 : Unit -> (Error Unit ::: NonTerm) Float) <-
    let (var_4 : Int -> (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Float)) <- multParamsFun in
    let (var_5 : Int) <- return [Error Unit ::: NonTerm] 1 in
    var_4 var_5 in
  let (var_7 : Unit) <- return [Error Unit ::: NonTerm] unit in
  var_6 var_7;

higherOrderLambda : (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Unit) =
  let (var_8 : (Unit -> (Error Unit ::: NonTerm) Unit) -> (Error Unit ::: NonTerm) (Unit -> (Error Unit ::: NonTerm) Unit)) <-
    return [Error Unit ::: NonTerm] \(x : Unit -> (Error Unit ::: NonTerm) Unit) ->
      return [Error Unit ::: NonTerm] x in
  let (var_9 : Unit -> (Error Unit ::: NonTerm) Unit) <-
    return [Error Unit ::: NonTerm] \(x : Unit) ->
      return [Error Unit ::: NonTerm] x in
  var_8 var_9;

ioFun : (Error Unit ::: NonTerm) ((Error Unit ::: (NonTerm ::: IO)) Int -> (Error Unit ::: (NonTerm ::: IO)) Int) =
  return [Error Unit ::: NonTerm] \(f : (Error Unit ::: (NonTerm ::: IO)) Int) -> f;

stateFun : (Error Unit ::: NonTerm) ((Error Unit ::: (NonTerm ::: State)) Unit -> (Error Unit ::: (NonTerm ::: State)) Unit) =
  return [Error Unit ::: NonTerm] \(f : (Error Unit ::: (NonTerm ::: State)) Unit) -> f;

