type String
  = Empty_Str
  | Cons_Str Char String;

type Pair A B
  = MkPair A B;

con_True : (Error Unit ::: NonTerm) Bool =
  return [Error Unit ::: NonTerm] True;

con_False : (Error Unit ::: NonTerm) Bool =
  return [Error Unit ::: NonTerm] False;

printString : (Error Unit ::: NonTerm) (String -> (Error Unit ::: (NonTerm ::: IO)) Unit) =
  return [Error Unit ::: NonTerm] \(s : String) ->
    return [Error Unit ::: (NonTerm ::: IO)] unit;

readString : (Error Unit ::: (NonTerm ::: IO)) String =
  return [Error Unit ::: (NonTerm ::: IO)] Empty_Str;

printInt : (Error Unit ::: NonTerm) (Int -> (Error Unit ::: (NonTerm ::: IO)) Unit) =
  return [Error Unit ::: NonTerm] \(i : Int) ->
    return [Error Unit ::: (NonTerm ::: IO)] unit;

readInt : (Error Unit ::: (NonTerm ::: IO)) Int =
  return [Error Unit ::: (NonTerm ::: IO)] 1;

printFloat : (Error Unit ::: NonTerm) (Float -> (Error Unit ::: (NonTerm ::: IO)) Unit) =
  return [Error Unit ::: NonTerm] \(f : Float) ->
    return [Error Unit ::: (NonTerm ::: IO)] unit;

readFloat : (Error Unit ::: (NonTerm ::: IO)) Float =
  return [Error Unit ::: (NonTerm ::: IO)] 1.0;

con_MkPair : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) (forall B . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) (Pair A B))))) =
  return [Error Unit ::: NonTerm] /\A .
    return [Error Unit ::: NonTerm] /\B .
      return [Error Unit ::: NonTerm] \(var_0 : A) ->
        return [Error Unit ::: NonTerm] \(var_1 : B) ->
          return [Error Unit ::: NonTerm] MkPair [A] [B] var_0 var_1;

main : (Error Unit ::: (NonTerm ::: IO)) Unit =
  return [Error Unit ::: (NonTerm ::: IO)] unit;

id : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) A)) =
  return [Error Unit ::: NonTerm] /\A .
    return [Error Unit ::: NonTerm] \(x : A) ->
      return [Error Unit ::: NonTerm] x;

idInt : (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) Int) =
  let (var_2 : forall A . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) A)) <- id in
    var_2 [Int];

idFun : (Error Unit ::: NonTerm) ((forall B . (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) B)) -> (Error Unit ::: NonTerm) (forall C . (Error Unit ::: NonTerm) (C -> (Error Unit ::: NonTerm) C))) =
  let (var_3 : forall A . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) A)) <- id in
    var_3 [forall A . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) A)];

idFunApp : (Error Unit ::: NonTerm) (forall T . (Error Unit ::: NonTerm) (T -> (Error Unit ::: NonTerm) T)) =
  let (var_4 : (forall B . (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) B)) -> (Error Unit ::: NonTerm) (forall C . (Error Unit ::: NonTerm) (C -> (Error Unit ::: NonTerm) C))) <- idFun in
  let (var_5 : forall A . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) A)) <- id in
  var_4 var_5;

polyApp : (Error Unit ::: NonTerm) Unit =
  let (var_12 : Int -> (Error Unit ::: NonTerm) Unit) <-
    let (var_10 : (Int -> (Error Unit ::: NonTerm) Unit) -> (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) Unit)) <-
      let (var_9 : forall B . (Error Unit ::: NonTerm) ((Int -> (Error Unit ::: NonTerm) B) -> (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) B))) <-
        let (var_8 : forall A . (Error Unit ::: NonTerm) (forall B . (Error Unit ::: NonTerm) ((A -> (Error Unit ::: NonTerm) B) -> (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) B)))) <-
          return [Error Unit ::: NonTerm] /\A .
            return [Error Unit ::: NonTerm] /\B .
              return [Error Unit ::: NonTerm] \(f : A -> (Error Unit ::: NonTerm) B) ->
                return [Error Unit ::: NonTerm] \(x : A) ->
                  let (var_6 : A -> (Error Unit ::: NonTerm) B) <-
                    return [Error Unit ::: NonTerm] f in
                  let (var_7 : A) <-
                    return [Error Unit ::: NonTerm] x in
                  var_6 var_7 in
        var_8 [Int] in
      var_9 [Unit] in
    let (var_11 : Int -> (Error Unit ::: NonTerm) Unit) <-
      return [Error Unit ::: NonTerm] \(x : Int) ->
        return [Error Unit ::: NonTerm] unit in
    var_10 var_11 in
 let (var_13 : Int) <-
   return [Error Unit ::: NonTerm] 1 in
  var_12 var_13;

compose : (Error Unit ::: NonTerm) (forall A . (Error Unit ::: NonTerm) (forall B . (Error Unit ::: NonTerm) (forall C . (Error Unit ::: NonTerm) ((B -> (Error Unit ::: NonTerm) C) -> (Error Unit ::: NonTerm) ((A -> (Error Unit ::: NonTerm) B) -> (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) C)))))) =
  return [Error Unit ::: NonTerm] /\A .
    return [Error Unit ::: NonTerm] /\B .
      return [Error Unit ::: NonTerm] /\C .
        return [Error Unit ::: NonTerm] \(f : B -> (Error Unit ::: NonTerm) C) ->
          return [Error Unit ::: NonTerm] \(g : A -> (Error Unit ::: NonTerm) B) ->
            return [Error Unit ::: NonTerm] \(x : A) ->
              let (var_16 : B -> (Error Unit ::: NonTerm) C) <-
                return [Error Unit ::: NonTerm] f in
              let (var_17 : B) <-
                let (var_14 : A -> (Error Unit ::: NonTerm) B) <-
                  return [Error Unit ::: NonTerm] g in
                let (var_15 : A) <-
                  return [Error Unit ::: NonTerm] x in
                var_14 var_15 in
              var_16 var_17;

mkIntPair : (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) (Pair Int Int))) =
  let (var_19 : forall B . (Error Unit ::: NonTerm) (Int -> (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) (Pair Int B)))) <-
    let (var_18 : forall A . (Error Unit ::: NonTerm) (forall B . (Error Unit ::: NonTerm) (A -> (Error Unit ::: NonTerm) (B -> (Error Unit ::: NonTerm) (Pair A B))))) <-
      con_MkPair in
    var_18 [Int] in
  var_19 [Int];

