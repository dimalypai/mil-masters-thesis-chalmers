main : IO Unit
main = do
  return [IO] unit;
end;;

type Pair A B = MkPair A B

fun : Unit
fun = ((unit));;

fun2 : forall A . forall B . A -> B -> Pair A B
fun2 = MkPair;;

type Fun = MkFun Int Unit

app : Fun
app = MkFun 1 unit;;

fun4 : Unit
fun4 = fun;;

lamFun : Int -> Unit -> Float
lamFun = \x : Int y : Unit . 0.01;;

lamFun2 : Int -> Unit -> Float
lamFun2 = \x : Int . \y : Unit . 0.02;;

lamApp1 : Unit -> Float
lamApp1 = lamFun 1;;

lamApp2 : Float
lamApp2 = lamApp1 unit;;

lamApp3 : Unit -> Float
lamApp3 = lamFun2 1;;

lamApp4 : Float
lamApp4 = lamFun2 1 unit;;

lamFun3 : Unit -> Unit
lamFun3 = (\x : Unit -> Unit . x) (\x : Unit . x);;

id : forall A . A -> A
id = /\A . \x : A . x;;

# Monomorphising id with Int
idInt : Int -> Int
idInt = id [Int];;

# "Monomorphising" id with polymorphic type
# This checks for alpha equivalence as well
idFun : (forall B . B -> B) -> (forall C . C -> C)
idFun = id [forall A . A -> A];;

# This checks for alpha equivalence
idFunApp : forall T . T -> T
idFunApp = idFun id;;

# Polymorphic function application
typeAppsFun : Unit
typeAppsFun = (/\A . /\B . \f : A -> B . \x : A . f x) [Int] [Unit] (\x : Int . unit) 1;;

# Function composition with non-nested lambdas
compose : forall A . forall B . forall C . (B -> C) -> (A -> B) -> A -> C
compose = /\A B C . \f : B -> C g : A -> B x : A . f (g x);;

# Monomorphising polymorphic data constructor
mkIntPair : Int -> Int -> Pair Int Int
mkIntPair = MkPair [Int] [Int];;

